<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SR LUDO | Battles</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #040913;
      --card: #0d1b33;
      --card-2: #102340;
      --text: #e8efff;
      --muted: #9fb0d1;
      --line: rgba(255, 255, 255, 0.08);
      --accent: #2f7bff;
      --accent-2: #18b3ff;
      --gold-1: #a86b00;
      --gold-2: #ffd05a;
      --danger: #ff3d4d;
      --ok: #38d17f;
      --warn: #ffb34a;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Inter', system-ui, sans-serif;
      background: radial-gradient(1200px 500px at 50% -200px, #154b99 0%, var(--bg) 65%);
      color: var(--text);
    }
    .app {
      max-width: 540px;
      margin: 0 auto;
      min-height: 100vh;
      border-left: 1px solid rgba(255,255,255,.05);
      border-right: 1px solid rgba(255,255,255,.05);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,0));
      padding-bottom: 86px;
    }
    .sticky-header {
      position: sticky;
      top: 0;
      z-index: 30;
      backdrop-filter: blur(10px);
      background: rgba(4, 9, 19, 0.88);
      border-bottom: 1px solid var(--line);
      padding: 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .back-btn {
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      text-decoration: none;
      font-size: 13px;
      white-space: nowrap;
    }
    .wallets { display: flex; gap: 8px; }
    .pill {
      min-width: 108px;
      border-radius: 999px;
      padding: 7px 11px;
      font-size: 12px;
      border: 1px solid rgba(255,255,255,.24);
    }
    .pill strong { display: block; margin-top: 1px; font-size: 14px; }
    .cash { background: linear-gradient(130deg, #0f49b3, #2a89ff); }
    .winning { background: linear-gradient(130deg, var(--gold-1), var(--gold-2)); color: #1f1711; }

    .content { padding: 14px; }
    .section { margin-top: 14px; }
    .row { display: flex; gap: 8px; align-items: center; }
    .space-between { justify-content: space-between; }
    .online {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.03);
      border-radius: 999px;
      padding: 8px 12px;
      color: var(--muted);
      font-size: 12px;
    }
    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--danger);
      box-shadow: 0 0 10px var(--danger);
      animation: blink 1.05s infinite;
    }
    @keyframes blink {
      0%,100% { opacity: 1; transform: scale(1); }
      50% { opacity: .35; transform: scale(.8); }
    }
    .btn {
      border: 0;
      border-radius: 12px;
      padding: 11px 12px;
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      background: linear-gradient(100deg, var(--accent), var(--accent-2));
    }
    .btn-muted {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      color: var(--text);
      background: rgba(255,255,255,.05);
      cursor: pointer;
    }
    .btn-gold { background: linear-gradient(130deg, #9b6400, #ffcf57); color: #1f1711; }
    .btn-danger { background: linear-gradient(120deg, #c71c30, #ff3d4d); }
    .btn-win { background: linear-gradient(120deg, #0f8f45, #25cc71); }
    .full { width: 100%; }

    .card {
      margin-top: 10px;
      background: linear-gradient(160deg, var(--card), var(--card-2));
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
    }
    .muted { color: var(--muted); }
    .title { margin: 0; font-size: 17px; }
    .small { font-size: 12px; }
    .input {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: rgba(255,255,255,.03);
      color: var(--text);
      padding: 12px;
      outline: none;
    }
    .status {
      display: inline-flex;
      align-items: center;
      font-size: 11px;
      border-radius: 999px;
      border: 1px solid var(--line);
      padding: 5px 9px;
    }
    .st-open { color: var(--warn); }
    .st-playing { color: #82b9ff; }
    .st-dispute { color: #ffc978; }
    .st-completed { color: #7fffbc; }
    .room-code {
      margin-top: 8px;
      font-size: 30px;
      letter-spacing: 1px;
      font-weight: 800;
      color: #ffd76c;
      text-align: center;
      border: 1px dashed rgba(255, 215, 108, 0.6);
      border-radius: 12px;
      padding: 8px;
    }

    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      display: none;
      z-index: 50;
    }
    .overlay.show { display: block; }
    .modal {
      position: fixed;
      z-index: 60;
      width: min(92%, 460px);
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border: 1px solid var(--line);
      border-radius: 16px;
      background: #08162c;
      padding: 14px;
      display: none;
    }
    .modal.show { display: block; }
  </style>
</head>
<body>
  <div class="app">
    <header class="sticky-header">
      <a class="back-btn" href="index.html">← Home</a>
      <div class="wallets">
        <div class="pill cash">Cash<strong id="cashAmount">₹0</strong></div>
        <div class="pill winning">Winning<strong id="winAmount">₹0</strong></div>
      </div>
    </header>

    <main class="content">
      <section class="section row space-between">
        <div class="online"><span class="dot"></span> Online Players: <strong id="onlinePlayers">500+</strong></div>
        <button id="rulesBtn" class="btn-muted" type="button">Rules</button>
      </section>

      <section class="section card">
        <h3 class="title">Create Battle</h3>
        <p class="muted small">Enter amount (multiples of 50 only). Smart deduction: win_balance first, then cash wallet.</p>
        <div class="row">
          <input id="battleAmount" class="input" type="number" min="50" step="50" placeholder="e.g. 100" />
          <button id="createBattleBtn" class="btn" type="button">Create</button>
        </div>
      </section>

      <section class="section">
        <h3 class="title">Open Battles</h3>
        <div id="openBattles"></div>
      </section>

      <section class="section">
        <h3 class="title">My Running Battles</h3>
        <div id="runningBattles"></div>
      </section>
    </main>
  </div>

  <div id="overlay" class="overlay"></div>

  <section id="rulesModal" class="modal" role="dialog" aria-modal="true">
    <h3 class="title">Battle Rules</h3>
    <ul class="muted small">
      <li>Agar popular code aye toh aap screen recording karke game left kare</li>
      <li>Agar samne wale theme Se khel raha he apko nahi khelna toh opponent ki 2 goti khulne se phele game screen recording karke game left kare</li>
      <li>Fake Screenshot Dalne Par 50 Rupay Penalty Lagegi</li>
      <li>withdrawl within 15 minutes me diya jata hai</li>
       <li>game cancel karte time reason aur screenshot dono admin ko send kare</li>
    </ul>
    <button class="btn full" data-close-modal="rulesModal" type="button">Close</button>
  </section>

  <section id="winModal" class="modal" role="dialog" aria-modal="true">
    <h3 class="title">Upload Winning Screenshot</h3>
    <p class="small muted">Screenshot required for "I WIN" claim. Match will move to dispute for admin verification.</p>
    <input id="winFile" class="input" type="file" accept="image/*" />
    <div class="row" style="margin-top:10px;">
      <button id="submitWinBtn" class="btn btn-gold full" type="button">Upload & Submit</button>
      <button class="btn-muted" data-close-modal="winModal" type="button">Cancel</button>
    </div>
  </section>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
    import {
      getDatabase,
      ref,
      onValue,
      push,
      get,
      set,
      update,
      runTransaction
    } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js';

    const firebaseConfig = {
      apiKey: 'AIzaSyAx0fr47IsOtBxakcBj1ndwDYle_XlaE-Y',
      authDomain: 'sr-ludo-4440b.firebaseapp.com',
      databaseURL: 'https://sr-ludo-4440b-default-rtdb.firebaseio.com',
      projectId: 'sr-ludo-4440b',
      storageBucket: 'sr-ludo-4440b.firebasestorage.app',
      messagingSenderId: '1080387235822',
      appId: '1:1080387235822:web:77faea231641837950e8ff'
    };

    const IMGBB_API_KEY = window.IMGBB_API_KEY || localStorage.getItem('ca44783bda6779b5e3913432bd243b30') || 'ca44783bda6779b5e3913432bd243b30';

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    const normalizePhone = (value) => {
      const cleaned = (value || '').toString().trim().replace(/[^\d+]/g, '');
      if (!cleaned) return '';
      return cleaned.startsWith('+') ? cleaned : `+${cleaned}`;
    };

    const phone = normalizePhone(localStorage.getItem('sr_ludo_phone'));
    if (!phone) {
      window.location.href = 'index.html';
      throw new Error('Phone missing. Redirecting to login.');
    }
    localStorage.setItem('sr_ludo_phone', phone);

    const cashAmount = document.getElementById('cashAmount');
    const winAmount = document.getElementById('winAmount');
    const battleAmount = document.getElementById('battleAmount');
    const createBattleBtn = document.getElementById('createBattleBtn');
    const openBattles = document.getElementById('openBattles');
    const runningBattles = document.getElementById('runningBattles');
    const rulesBtn = document.getElementById('rulesBtn');
    const rulesModal = document.getElementById('rulesModal');
    const winModal = document.getElementById('winModal');
    const overlay = document.getElementById('overlay');
    const submitWinBtn = document.getElementById('submitWinBtn');
    const winFile = document.getElementById('winFile');

    let myUser = null;
    let pendingWinBattleId = null;

    const fmt = (n = 0) => `₹${Number(n || 0).toLocaleString('en-IN')}`;
    const statusClass = (st = '') => ({ open: 'st-open', playing: 'st-playing', dispute: 'st-dispute', completed: 'st-completed' }[st] || '');
    const computeWinAmount = (amount) => ({ 100: 190, 500: 970 }[Number(amount)] ?? Math.floor(Number(amount) * 1.9));

    const showModal = (node) => { node.classList.add('show'); overlay.classList.add('show'); };
    const closeModal = (node) => { node.classList.remove('show'); if (!document.querySelector('.modal.show')) overlay.classList.remove('show'); };

    const validateAmount = (amount) => Number.isFinite(amount) && amount > 0 && amount % 50 === 0;

    async function deductSmartWallet(userPhone, amount) {
      const userRef = ref(db, `users/${userPhone}`);
      let deduction = null;
      const result = await runTransaction(userRef, (user) => {
        if (!user) return user;
        const winBal = Number(user.win_balance || 0);
        const cashBal = Number(user.balance || 0);
        const total = winBal + cashBal;
        if (total < amount) return;

        const fromWin = Math.min(winBal, amount);
        const fromCash = amount - fromWin;
        user.win_balance = winBal - fromWin;
        user.balance = cashBal - fromCash;
        deduction = { fromWin, fromCash };
        return user;
      });

      if (!result.committed || !deduction) throw new Error('Insufficient wallet balance.');
      return deduction;
    }

    async function creditCash(userPhone, amount) {
      await runTransaction(ref(db, `users/${userPhone}`), (user) => {
        if (!user) return user;
        user.balance = Number(user.balance || 0) + Number(amount || 0);
        return user;
      });
    }

    async function creditWinning(userPhone, amount) {
      await runTransaction(ref(db, `users/${userPhone}`), (user) => {
        if (!user) return user;
        user.win_balance = Number(user.win_balance || 0) + Number(amount || 0);
        return user;
      });
    }

    async function creditReferralCommission(winnerPhone, winningAmount) {
      const winnerSnap = await get(ref(db, `users/${winnerPhone}`));
      const winner = winnerSnap.val() || {};
      const referrerPhone = normalizePhone(winner.referredBy);
      if (!referrerPhone || referrerPhone === winnerPhone) return;

      const commission = Number((Number(winningAmount || 0) * 0.02).toFixed(2));
      if (!commission) return;

      await runTransaction(ref(db, `users/${referrerPhone}`), (user) => {
        if (!user) return user;
        user.referral_balance = Number(user.referral_balance || 0) + commission;
        return user;
      });

      await runTransaction(ref(db, `referrals/${referrerPhone}/earnings_total`), (amount) => Number(amount || 0) + commission);
      await set(ref(db, `referrals/${referrerPhone}/friends_list/${winnerPhone}`), {
        phone: winnerPhone,
        joinedAt: winner.time || Date.now()
      });

      const historyRef = push(ref(db, `referrals/${referrerPhone}/referral_history`));
      await set(historyRef, {
        id: historyRef.key,
        winnerPhone,
        winnerName: winner.name || winner.full_name || winnerPhone,
        message: `Earned ₹${commission} from ${(winner.name || winner.full_name || 'Player')}'s win.`,
        amount: commission,
        sourcePrize: Number(winningAmount || 0),
        time: Date.now()
      });
    }

    async function createBattle() {
      const amount = Number(battleAmount.value);
      if (!validateAmount(amount)) {
        alert('Battle amount should be a multiple of 50.');
        return;
      }

      createBattleBtn.disabled = true;
      try {
        const deduction = await deductSmartWallet(phone, amount);
        const battleRef = push(ref(db, 'battles'));
        await set(battleRef, {
          id: battleRef.key,
          amount,
          winAmount: computeWinAmount(amount),
          status: 'open',
          creatorPhone: phone,
          creatorDeduct: deduction,
          createdAt: Date.now(),
          updatedAt: Date.now()
        });
        battleAmount.value = '';
      } catch (error) {
        alert(error.message || 'Unable to create battle.');
      } finally {
        createBattleBtn.disabled = false;
      }
    }

    async function cancelOpenBattle(battleId) {
      const battleRef = ref(db, `battles/${battleId}`);
      const tx = await runTransaction(battleRef, (battle) => {
        if (!battle || battle.status !== 'open' || battle.creatorPhone !== phone) return;
        battle.status = 'cancelled';
        battle.cancelledAt = Date.now();
        battle.updatedAt = Date.now();
        return battle;
      });

      if (!tx.committed) {
        alert('Cannot cancel this battle now.');
        return;
      }

      const battle = tx.snapshot.val();
      await creditCash(phone, Number(battle.amount || 0));
    }

    async function joinBattle(battleId) {
      const battleRef = ref(db, `battles/${battleId}`);
      const claimTx = await runTransaction(battleRef, (battle) => {
        if (!battle || battle.status !== 'open') return;
        if (battle.creatorPhone === phone) return;
        battle.status = 'joining';
        battle.joinerPhone = phone;
        battle.joiningAt = Date.now();
        battle.updatedAt = Date.now();
        return battle;
      });

      if (!claimTx.committed) {
        alert('Battle already taken.');
        return;
      }

      const battle = claimTx.snapshot.val();
      try {
        const deduction = await deductSmartWallet(phone, Number(battle.amount));
        await update(battleRef, {
          status: 'playing',
          joinerDeduct: deduction,
          startedAt: Date.now(),
          updatedAt: Date.now()
        });
      } catch (error) {
        await runTransaction(battleRef, (curr) => {
          if (!curr || curr.status !== 'joining' || curr.joinerPhone !== phone) return curr;
          curr.status = 'open';
          delete curr.joinerPhone;
          delete curr.joiningAt;
          curr.updatedAt = Date.now();
          return curr;
        });
        alert(error.message || 'Unable to join battle.');
      }
    }

    async function writeMatchHistoryEntry(playerPhone, battle, result) {
      if (!playerPhone || !battle?.id) return;
      await update(ref(db, `match_history/${playerPhone}/${battle.id}`), {
        battle_id: battle.id,
        entry_fee: Number(battle.amount || 0),
        prize: Number(battle.winAmount || 0),
        status: result,
        timestamp: Date.now(),
        time: Date.now(),
        creatorPhone: battle.creatorPhone || '',
        joinerPhone: battle.joinerPhone || ''
      });
    }

    async function setRoomCode(battleId, code) {
      const roomCode = (code || '').trim();
      if (!roomCode) return alert('Enter room code first.');
      await runTransaction(ref(db, `battles/${battleId}`), (battle) => {
        if (!battle || battle.status !== 'playing' || battle.creatorPhone !== phone) return battle;
        battle.roomCode = roomCode;
        battle.room_code = roomCode;
        battle.roomCodeAt = Date.now();
        battle.updatedAt = Date.now();
        return battle;
      });
    }

    async function declareLost(battleId) {
      const battleRef = ref(db, `battles/${battleId}`);
      const tx = await runTransaction(battleRef, (battle) => {
        if (!battle || !['playing', 'dispute'].includes(battle.status) || battle.settledAt) return;
        const isCreator = battle.creatorPhone === phone;
        const isJoiner = battle.joinerPhone === phone;
        if (!isCreator && !isJoiner) return;
        battle.status = 'completed';
        battle.loserPhone = phone;
        battle.winnerPhone = isCreator ? battle.joinerPhone : battle.creatorPhone;
        battle.resultType = 'lost-declared';
        battle.settledAt = Date.now();
        battle.updatedAt = Date.now();
        return battle;
      });

      if (!tx.committed) return alert('Unable to process result.');
      const data = tx.snapshot.val();
      const winAmt = Number(data.winAmount || 0);
      await creditWinning(data.winnerPhone, winAmt);
      await creditReferralCommission(data.winnerPhone, winAmt);
      await writeMatchHistoryEntry(data.creatorPhone, data, data.creatorPhone === data.winnerPhone ? 'win' : 'lost');
      await writeMatchHistoryEntry(data.joinerPhone, data, data.joinerPhone === data.winnerPhone ? 'win' : 'lost');
    }

    async function uploadToImgBB(file) {
      if (!IMGBB_API_KEY || IMGBB_API_KEY === 'ca44783bda6779b5e3913432bd243b30') {
        throw new Error('ImgBB API key missing in battles.html');
      }
      const fd = new FormData();
      fd.append('image', file);
      const resp = await fetch(`https://api.imgbb.com/1/upload?key=${ca44783bda6779b5e3913432bd243b30}`, { method: 'POST', body: fd });
      const json = await resp.json();
      const url = json?.data?.url;
      if (!url) throw new Error('Screenshot upload failed.');
      return url;
    }

    async function declareWinWithScreenshot() {
      if (!pendingWinBattleId) return;
      const file = winFile.files[0];
      if (!file) return alert('Please upload screenshot first.');

      submitWinBtn.disabled = true;
      try {
        const url = await uploadToImgBB(file);
        const tx = await runTransaction(ref(db, `battles/${pendingWinBattleId}`), (battle) => {
          if (!battle || battle.status !== 'playing' || battle.settledAt) return;
          const isParticipant = [battle.creatorPhone, battle.joinerPhone].includes(phone);
          if (!isParticipant) return;
          battle.status = 'completed';
          battle.win_claim_by = phone;
          battle.win_ss = battle.win_ss || {};
          battle.win_ss[phone] = url;
          battle.winnerPhone = phone;
          battle.loserPhone = battle.creatorPhone === phone ? battle.joinerPhone : battle.creatorPhone;
          battle.resultType = 'win-declared';
          battle.settledAt = Date.now();
          battle.updatedAt = Date.now();
          return battle;
        });

        if (!tx.committed) throw new Error('Unable to submit win result.');

        const resultBattle = tx.snapshot.val();
        const winAmt = Number(resultBattle.winAmount || 0);
        await creditWinning(resultBattle.winnerPhone, winAmt);
        await creditReferralCommission(resultBattle.winnerPhone, winAmt);
        await writeMatchHistoryEntry(resultBattle.creatorPhone, resultBattle, resultBattle.creatorPhone === resultBattle.winnerPhone ? 'win' : 'lost');
        await writeMatchHistoryEntry(resultBattle.joinerPhone, resultBattle, resultBattle.joinerPhone === resultBattle.winnerPhone ? 'win' : 'lost');
        closeModal(winModal);
        pendingWinBattleId = null;
        winFile.value = '';
      } catch (error) {
        alert(error.message || 'Unable to submit claim.');
      } finally {
        submitWinBtn.disabled = false;
      }
    }

    function renderOpenBattles(data) {
      const list = Object.values(data || {}).filter((b) => b?.status === 'open').sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
      if (!list.length) {
        openBattles.innerHTML = '<div class="card muted small">No open battles right now.</div>';
        return;
      }

      openBattles.innerHTML = list.map((b) => {
        const mine = b.creatorPhone === phone;
        return `
          <div class="card">
            <div class="row space-between">
              <strong>₹${b.amount}</strong>
              <span class="status ${statusClass(b.status)}">${b.status.toUpperCase()}</span>
            </div>
            <div class="small muted">Win Amount: ${fmt(b.winAmount)} • ID: ${b.id}</div>
            <div class="row" style="margin-top:10px;">
              ${mine
                ? `<button class="btn-danger btn full" data-action="cancel" data-id="${b.id}" type="button">Cancel (Refund to Cash)</button>`
                : `<button class="btn btn-gold full" data-action="join" data-id="${b.id}" type="button">Join Battle</button>`}
            </div>
          </div>
        `;
      }).join('');
    }

    function battleControls(b) {
      const meCreator = b.creatorPhone === phone;
      const meJoiner = b.joinerPhone === phone;
      const meParticipant = meCreator || meJoiner;
      if (!meParticipant) return '';

      const roomCode = b.room_code || b.roomCode || '';
      const roomInput = meCreator
        ? `<div class="row" style="margin-top:8px;">
            <input class="input" id="room-${b.id}" placeholder="Enter Room Code" value="${roomCode}" />
            <button class="btn btn-gold" data-action="set-room" data-id="${b.id}" type="button">SET</button>
           </div>`
        : (roomCode ? `<div class="room-code">${roomCode}</div>` : '<div class="small muted" style="margin-top:8px;">Waiting for creator to set room code...</div>');

      const actionDisplay = roomCode ? 'flex' : 'none';
      return `
        ${roomInput}
        <div class="row" style="margin-top:10px;display:${actionDisplay};">
          <button class="btn btn-win full" data-action="i-win" data-id="${b.id}" type="button">I WIN</button>
          <button class="btn btn-danger full" data-action="i-lost" data-id="${b.id}" type="button">I LOST</button>
        </div>
      `;
    }

    function renderRunningBattles(data) {
      const completedStatuses = ['completed', 'win', 'lost'];
      const list = Object.values(data || {})
        .filter((b) => [b.creatorPhone, b.joinerPhone].includes(phone) && ['playing', 'dispute'].includes(b.status) && !completedStatuses.includes(b.status))
        .sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));

      if (!list.length) {
        runningBattles.innerHTML = '<div class="card muted small">No running battles.</div>';
        return;
      }

      runningBattles.innerHTML = list.map((b) => `
        <div class="card" id="running-${b.id}" data-battle-id="${b.id}">
          <div class="row space-between">
            <strong>Battle ₹${b.amount}</strong>
            <span class="status ${statusClass(b.status)}">${b.status.toUpperCase()}</span>
          </div>
          <div class="small muted">Win: ${fmt(b.winAmount)} • Creator: ${b.creatorPhone} • Joiner: ${b.joinerPhone || '-'}</div>
          ${b.winnerPhone ? `<div class="small" style="margin-top:6px;color:var(--ok);">Winner: ${b.winnerPhone}</div>` : ''}
          ${battleControls(b)}
        </div>
      `).join('');
    }

    createBattleBtn.addEventListener('click', createBattle);

    rulesBtn.addEventListener('click', () => showModal(rulesModal));
    overlay.addEventListener('click', () => {
      document.querySelectorAll('.modal.show').forEach((m) => m.classList.remove('show'));
      overlay.classList.remove('show');
    });
    document.querySelectorAll('[data-close-modal]').forEach((btn) => {
      btn.addEventListener('click', () => closeModal(document.getElementById(btn.dataset.closeModal)));
    });

    submitWinBtn.addEventListener('click', declareWinWithScreenshot);

    document.body.addEventListener('click', async (event) => {
      const btn = event.target.closest('button[data-action]');
      if (!btn) return;
      const action = btn.dataset.action;
      const id = btn.dataset.id;
      try {
        if (action === 'cancel') await cancelOpenBattle(id);
        if (action === 'join') await joinBattle(id);
        if (action === 'i-lost') await declareLost(id);
        if (action === 'i-win') {
          pendingWinBattleId = id;
          showModal(winModal);
        }
        if (action === 'set-room') {
          const roomInput = document.getElementById(`room-${id}`);
          await setRoomCode(id, roomInput?.value || '');
        }
      } catch (error) {
        alert(error.message || 'Action failed.');
      }
    });

    onValue(ref(db, `users/${phone}`), (snap) => {
      myUser = snap.val() || {};
      cashAmount.textContent = fmt(myUser.balance);
      winAmount.textContent = fmt(myUser.win_balance);
    });

    onValue(ref(db, 'app_stats/online_players'), (snap) => {
      const val = snap.val();
      document.getElementById('onlinePlayers').textContent = val ? `${val}+` : '500+';
    });

    onValue(ref(db, 'battles'), (snap) => {
      const battles = snap.val() || {};
      Object.values(battles).forEach((battle) => {
        if (!battle?.id) return;
        if (['completed', 'win', 'lost'].includes(battle.status)) {
          const node = document.getElementById(`running-${battle.id}`);
          if (node) node.remove();
        }
      });
      renderOpenBattles(battles);
      renderRunningBattles(battles);
    });
  </script>
</body>
</html>
